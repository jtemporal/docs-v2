### Prerequisites

Before getting started, make sure you have completed the following steps:

- Create an [Auth0 Account](https://auth0.com/signup?onboard_app=genai&ocid=7014z000001NyoxAAC-aPA4z0000008OZeGAM) and a Dev Tenant
- Setup and configure a [Google Cloud Project](https://developers.google.com/workspace/guides/create-project) for use with the Google Connection
   - Enable the [Google Calendar API](https://console.cloud.google.com/apis/library/calendar-json.googleapis.com).
   - Create OAuth 2.0 credentials with proper redirect URIs.
- Set up an [OpenAI account and API key](https://platform.openai.com/docs/libraries#create-and-export-an-api-key)

<Info>
This guide showcases **Federation Connections with Access Tokens**, a new feature that enables a SPA and a linked API to exchange a user's access token for a third-party access token. This differs from the Next.js example which uses refresh tokens for the exchange.
</Info>

### Auth0 Configuration

#### 1. Create an Auth0 Single Page Application

- Go to your [Auth0 Dashboard](https://manage.auth0.com/)
- Create a new **Single Page Application**
- Configure the following settings:
  - **Allowed Callback URLs**: `http://localhost:5173`
  - **Allowed Logout URLs**: `http://localhost:5173`
  - **Allowed Web Origins**: `http://localhost:5173`
- Make sure to Allow Refresh Token in Grant Types under Advanced Settings but you can disable "Allow Refresh Token Rotation"

#### 2. Create an Auth0 API

- In your Auth0 Dashboard, go to APIs
- Create a new API with an identifier (audience)
- Make sure to "Allow Offline Access" in Access Settings
- Note down the API identifier for your environment variables

#### 3. Create a Resource Server Client (for Federated Token Exchange)

This is a special client that allows your API server to perform token exchanges using **access tokens instead of refresh tokens**.

Create this client programmatically via the Auth0 Management API:

```bash
curl -L 'https://{tenant}.auth0.com/api/v2/clients' \
-H 'Content-Type: application/json' \
-H 'Accept: application/json' \
-H 'Authorization: Bearer {MANAGEMENT_API_TOKEN}' \
-d '{
  "name": "Calendar API Resource Server Client",
  "app_type": "resource_server",
  "grant_types": ["urn:auth0:params:oauth:grant-type:token-exchange:federated-connection-access-token"],
  "resource_server_identifier": "YOUR_API_IDENTIFIER"
}'
```

- Note that your `MANAGEMENT_API_TOKEN` above must have the `create:clients` scope in order to work.
   - The Auth0 API Explorer test client under APIs -> Auth0 Management API -> API Explorer tab can be used when requesting this scope in an access token.
- Note down the `client_id` and `client_secret` for your environment variables after running curl successfully.
- This client enables federated token exchange to get access tokens for external connections (e.g., Google Calendar)

#### 4. Configure Social Connection

- Configure a Google Social Connection in Auth0
- Make sure to enable all `Calendar` scopes from the Permissions options
- Make sure to enable Token Vault for the Connection under the Advanced Settings
- Make sure to enable the connection for your SPA Application and the Resource Server Client
- Test the connection in Auth0 "Try Connection" screen

### Prepare React SPA + Hono API

**Recommended**: To use a starter template, clone the [Auth0 AI samples](https://github.com/auth0-lab/auth0-ai-js) repository:

```bash wrap lines
git clone https://github.com/auth0-lab/auth0-ai-js.git
cd auth0-ai-js/examples/calling-apis/spa-with-backend-api/react-hono-ai-sdk
```

### Install dependencies

In the root directory of your project, note some of the following dependencies:

**Client dependencies:**
- `@auth0/auth0-spa-js`: Auth0 SPA SDK for client-side authentication
- `@auth0/ai-vercel`: [Auth0 AI SDK for Vercel AI](https://github.com/auth0-lab/auth0-ai-js/tree/main/packages/ai-vercel) built for GenAI applications
- `ai`: Core [Vercel AI SDK](https://sdk.vercel.ai/docs) module

**Server dependencies:**
- `@hono/node-server`: Node.js server adapter for Hono
- `hono`: Lightweight web framework
- `ai`: Core [Vercel AI SDK](https://sdk.vercel.ai/docs) module
- `@ai-sdk/openai`: [OpenAI](https://sdk.vercel.ai/providers/ai-sdk-providers/openai) provider
- `googleapis`: Node.js client for Google APIs
- `jose`: JavaScript Object Signing and Encryption library for JWT verification

```bash wrap lines
# Install client & server dependencies from the root directory of the project.
# All workspace dependencies will be installed automatically.
npm install
```

### Update the environment files

#### Client (.env)
```bash .env wrap lines
VITE_AUTH0_DOMAIN=your-auth0-domain
VITE_AUTH0_CLIENT_ID=your-spa-client-id
VITE_AUTH0_AUDIENCE=your-api-identifier
VITE_API_URL=http://localhost:3001
```

#### Server (.env)
```bash .env wrap lines
AUTH0_DOMAIN=your-auth0-domain
AUTH0_AUDIENCE=your-api-identifier
AUTH0_CLIENT_ID=your-resource-server-client-id
AUTH0_CLIENT_SECRET=your-resource-server-client-secret
OPENAI_API_KEY=your-openai-api-key
PORT=3001
```

### Set up federated connection with access tokens

#### Configure the SPA for step-up authorization

Unlike the Next.js example which uses refresh tokens, this React SPA approach uses **access tokens** for federated token exchange. The SPA handles step-up authorization using Auth0 SPA SDK's `loginWithPopup()` method to display the consent screen, and allow the user to grant additional permissions.

Create `client/src/components/FederatedConnectionPopup.tsx`:

```tsx client/src/components/FederatedConnectionPopup.tsx wrap lines
import { useAuth0 } from "@auth0/auth0-spa-js";
import { useCallback, useState } from "react";

interface FederatedConnectionPopupProps {
  connection: string;
  requiredScopes: string[];
  onComplete: () => void;
}

export function FederatedConnectionPopup({
  connection,
  requiredScopes,
  onComplete,
}: FederatedConnectionPopupProps) {
  const { loginWithPopup } = useAuth0();
  const [isLoading, setIsLoading] = useState(false);

  const handleAuthorization = useCallback(async () => {
    setIsLoading(true);
    try {
      await loginWithPopup({
        connection,
        authorizationParams: {
          connection_scope: requiredScopes.join(" "),
          prompt: "consent",
          access_type: "offline",
        },
      });
      onComplete();
    } catch (error) {
      console.error("Authorization failed:", error);
    } finally {
      setIsLoading(false);
    }
  }, [connection, requiredScopes, loginWithPopup, onComplete]);

  return (
    <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4">
      <h3 className="text-lg font-semibold text-blue-900 mb-2">
        Authorization Required
      </h3>
      <p className="text-blue-800 mb-4">
        Additional permissions are needed to access your calendar.
      </p>
      <button
        onClick={handleAuthorization}
        disabled={isLoading}
        className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 disabled:opacity-50"
      >
        {isLoading ? "Authorizing..." : "Authorize Calendar Access"}
      </button>
    </div>
  );
}
```

#### Create tools with federated connection support

Create `server/src/lib/tools/listUserCalendars.ts`:

```ts server/src/lib/tools/listUserCalendars.ts wrap lines
import { tool } from "ai";
import { google } from "googleapis";
import { z } from "zod";

import { getAccessTokenForConnection } from "@auth0/ai-vercel";

import { withGoogleCalendar } from "../auth";

/**
 * Tool: listUserCalendars
 * Lists all calendars the user has access to.
 * Uses the enhanced @auth0/ai SDK for federated connection token management.
 */
export const listUserCalendars = withGoogleCalendar(
  tool({
    description: "List all calendars the user has access to",
    parameters: z.object({}),
    execute: async () => {
      // Get the federated access token using the enhanced SDK
      const token = getAccessTokenForConnection();

      const calendar = google.calendar("v3");
      const auth = new google.auth.OAuth2();
      auth.setCredentials({ access_token: token });

      const res = await calendar.calendarList.list({ auth });

      const calendars =
        res.data.items?.map((cal) => ({
          id: cal.id,
          name: cal.summary,
          accessRole: cal.accessRole,
        })) ?? [];

      return calendars;
    },
  })
);
```

Create `server/src/tools/listNearbyEvents.ts`:

```ts server/src/tools/listNearbyEvents.ts wrap lines
import { tool } from "ai";
import { google } from "googleapis";
import { z } from "zod";

import { getAccessTokenForConnection } from "@auth0/ai-vercel";

import { withGoogleCalendar } from "../auth";

/**
 * Tool: listNearbyEvents
 * Lists calendar events between a start and end time from a specified calendar.
 * Uses the enhanced @auth0/ai SDK for federated connection token management.
 */
export const listNearbyEvents = withGoogleCalendar(
  tool({
    description:
      "List calendar events between a given start and end time from a user's calendar (personal or shared)",
    parameters: z.object({
      start: z.coerce.date(),
      end: z.coerce.date(),
      calendarId: z.string().optional().default("primary"),
    }),
    execute: async ({ start, end, calendarId }) => {
      // Fix truncated calendar IDs by appending the correct suffix
      let fullCalendarId = calendarId;
      if (!calendarId.includes("@") && calendarId.startsWith("c_")) {
        fullCalendarId = `${calendarId}@group.calendar.google.com`;
      } else if (!calendarId.includes("@") && !calendarId.startsWith("c_")) {
        // For primary calendar (email format)
        fullCalendarId = calendarId; // Keep as is, it should be an email
      }

      // Get the federated access token using the enhanced SDK
      const token = getAccessTokenForConnection();

      const calendar = google.calendar("v3");
      const auth = new google.auth.OAuth2();
      auth.setCredentials({ access_token: token });

      const response = await calendar.events.list({
        auth,
        calendarId: fullCalendarId,
        timeMin: start.toISOString(),
        timeMax: end.toISOString(),
        singleEvents: true,
        orderBy: "startTime",
        maxResults: 10,
      });

      return {
        calendarId: fullCalendarId,
        events:
          response.data.items?.map((ev) => ({
            id: ev.id,
            summary: ev.summary,
            start: ev.start?.dateTime ?? ev.start?.date,
            end: ev.end?.dateTime ?? ev.end?.date,
            location: ev.location ?? "No location",
          })) ?? [],
      };
    },
  })
);
```

#### Configure the API server with federated connection wrapper

Create `server/src/lib/auth0.ts`:

```ts server/src/lib/auth0.ts wrap lines
import { Auth0AI } from "@auth0/ai-vercel";

const auth0AI = new Auth0AI({
  domain: process.env.AUTH0_DOMAIN!,
  // For federated token exchange, we need to supply the Resource Server Client ID and Secret referenced in the curl command above
  clientId: process.env.AUTH0_CLIENT_ID!,
  clientSecret: process.env.AUTH0_CLIENT_SECRET!,
});

// Configure federated connection wrapper for Google services
// This uses ACCESS TOKENS instead of refresh tokens for the exchange
export const withGoogleConnection = auth0AI.withTokenForConnection({
  connection: "google-oauth2",
  scopes: [
    "https://www.googleapis.com/auth/calendar.readonly",
    "https://www.googleapis.com/auth/calendar.events.readonly"
  ],
  // Use access token from SPA instead of refresh token
  accessToken: async () => {
    // The access token provided by the SPA will be used to exchange for a Google Calendar access token.
    // This can provided by the SPA via the Authorization header and set in Hono's authContext via a middleware or within the route handler.
    return global.authContext.accessToken;
  },
});
```

### Configure chat API with interrupt handling

Update `server/src/index.ts`:

```ts server/src/index.ts wrap lines
import {
  createDataStreamResponse,
  generateId,
  streamText,
  ToolExecutionError,
} from "ai";
import { Hono } from "hono";
import { cors } from "hono/cors";
import { decodeJwt } from "jose";

import { openai } from "@ai-sdk/openai";
import { setAIContext } from "@auth0/ai-vercel";
import {
  InterruptionPrefix,
  withInterruptions,
} from "@auth0/ai-vercel/interrupts";
import { Auth0Interrupt } from "@auth0/ai/interrupts";
import { serve } from "@hono/node-server";

import { listNearbyEvents } from "./lib/tools/listNearbyEvents";
import { listUserCalendars } from "./lib/tools/listUserCalendars";
import { jwtAuthMiddleware } from "./middleware/auth";

import type { ApiResponse } from "shared/dist";

export const app = new Hono()
  .post("/chat", jwtAuthMiddleware(), async (c) => {
    const user = c.get("user");
    console.log("ðŸ” Authenticated user:", user.sub);

    // Extract the access token
    const authHeader = c.req.header("authorization");
    const accessToken = authHeader?.replace("Bearer ", "");

    if (!accessToken) {
      return c.json({ error: "No access token provided" }, 401);
    }

    const { messages: requestMessages } = await c.req.json();

    // Generate a thread ID for this conversation
    const threadID = generateId();

    // Set global auth context for tools to access
    global.authContext = {
      userSub: user.sub,
      accessToken,
    };

    // Set AI context for the tools to access
    setAIContext({ threadID });

    // Use the messages from the request directly
    const tools = { listNearbyEvents, listUserCalendars };

    // note: you can see more examples of Hono API consumption with AI SDK here:
    // https://ai-sdk.dev/cookbook/api-servers/hono?utm_source=chatgpt.com#hono

    return createDataStreamResponse({
      execute: withInterruptions(
        async (dataStream) => {
          const result = streamText({
            model: openai("gpt-4o-mini"),
            system:
              "You are a helpful calendar assistant! You can help users with their calendar events and schedules. Keep your responses concise and helpful.",
            messages: requestMessages,
            maxSteps: 5,
            tools,
          });

          result.mergeIntoDataStream(dataStream, {
            sendReasoning: true,
          });
        },
        { messages: requestMessages, tools }
      ),
      onError: (error: any) => {
        // Handle Auth0 AI interrupts
        if (
          error instanceof ToolExecutionError &&
          error.cause instanceof Auth0Interrupt
        ) {
          const serializableError = {
            ...error.cause.toJSON(),
            toolCall: {
              id: error.toolCallId,
              args: error.toolArgs,
              name: error.toolName,
            },
          };

          return `${InterruptionPrefix}${JSON.stringify(serializableError)}`;
        }

        return "Oops! An error occurred.";
      },
    });
  });

// Start the server for Node.js
const port = Number(process.env.PORT) || 3000;

console.log(`ðŸš€ Server starting on port ${port}`);
serve({
  fetch: app.fetch,
  port,
});

console.log(`âœ… Server running on http://localhost:${port}`);
```

### Implement interrupt handling in React

Update your chat component to handle federated connection interrupts:

```tsx client/src/components/Chat.tsx wrap lines
import { Loader2, Send, Trash2 } from "lucide-react";

import { useChat } from "@ai-sdk/react";
import { useInterruptions } from "@auth0/ai-vercel/react";

import { useAuth0 } from "../hooks/useAuth0";
import { FederatedConnectionPopup } from "./FederatedConnectionPopup";
import { Button } from "./ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "./ui/card";
import { Input } from "./ui/input";

import type { Message } from "ai";

const InterruptionPrefix = "AUTH0_AI_INTERRUPTION:";
const SERVER_URL = import.meta.env.VITE_SERVER_URL;

export function Chat() {
  const { getToken } = useAuth0();

  const chatHelpers = useInterruptions((errorHandler) =>
    useChat({
      api: `${SERVER_URL}/chat`,
      fetch: (async (url: string | URL | Request, init?: RequestInit) => {
        const token = await getToken();
        return fetch(url, {
          ...init,
          headers: {
            "Content-Type": "application/json",
            ...init?.headers,
            Authorization: `Bearer ${token}`,
          },
        });
      }),
    })
  );

  const {
    messages,
    input,
    handleInputChange,
    handleSubmit,
    isLoading,
    error,
    setMessages,
    toolInterrupt,
  } = chatHelpers;

  // Filter out interrupted tool calls from messages
  let displayMessages = messages;

  if (toolInterrupt) {
    displayMessages = messages.map((message) => ({
      ...message,
      parts: message.parts?.map((part) =>
        part.type === "tool-invocation" &&
        part.toolInvocation.toolCallId === toolInterrupt.toolCall?.id
          ? {
              ...part,
              toolInvocation: {
                ...part.toolInvocation,
                state: "call",
              },
            }
          : part
      ),
    }));
  }

  const clearMessages = () => {
    setMessages([]);
  };

  return (
    <Card className="w-full max-w-2xl mx-auto">
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <CardTitle className="text-lg font-semibold">
          Calendar Assistant
        </CardTitle>
        {messages.length > 0 && (
          <Button
            variant="outline"
            size="sm"
            onClick={clearMessages}
            className="h-8 w-8 p-0"
          >
            <Trash2 className="h-4 w-4" />
          </Button>
        )}
      </CardHeader>
      <CardContent className="space-y-4">
        {/* Messages */}
        <div className="space-y-4 max-h-96 overflow-y-auto">
          {displayMessages.length === 0 ? (
            <div className="text-center text-muted-foreground py-8">
              <p className="text-sm">Ask me about your calendar events!</p>
              <p className="text-xs mt-1">
                Try: "What meetings do I have today?" or "Show me my upcoming
                events"
              </p>
            </div>
          ) : (
            displayMessages.map((message) => (
              <MessageBubble key={message.id} message={message} />
            ))
          )}
          {isLoading && (
            <div className="flex justify-start">
              <div className="bg-muted rounded-lg px-3 py-2 max-w-[80%] flex items-center gap-2">
                <Loader2 className="h-4 w-4 animate-spin" />
                <span className="text-sm text-muted-foreground">
                  Thinking...
                </span>
              </div>
            </div>
          )}
        </div>

        {/* Error message - hide if it's an Auth0 interrupt (we show the popup instead) */}
        {error && !error.message.startsWith(InterruptionPrefix) && (
          <div className="bg-destructive/10 text-destructive text-sm p-3 rounded-lg">
            Error: {error.message}
          </div>
        )}

        {/* Federated Connection Interrupt Handling */}
        {toolInterrupt && (
          <FederatedConnectionPopup interrupt={toolInterrupt} />
        )}

        {/* Input form */}
        <form onSubmit={handleSubmit} className="flex gap-2">
          <Input
            value={input}
            onChange={handleInputChange}
            placeholder="Ask about your calendar..."
            disabled={isLoading}
            className="flex-1"
          />
          <Button
            className="h-10"
            type="submit"
            disabled={isLoading || !input.trim()}
          >
            <Send className="h-4 w-4" />
          </Button>
        </form>
      </CardContent>
    </Card>
  );
}

function MessageBubble({ message }: { message: Message }) {
  const isUser = message.role === "user";

  return (
    <div className={`flex ${isUser ? "justify-end" : "justify-start"}`}>
      <div
        className={`rounded-lg px-3 py-2 max-w-[80%] ${
          isUser ? "bg-primary text-primary-foreground" : "bg-muted"
        }`}
      >
        <p className="text-sm whitespace-pre-wrap">{message.content}</p>
      </div>
    </div>
  );
}
```

### Key differences from Next.js approach

This React SPA implementation differs from the Next.js example in several important ways:

1. **Access Token Exchange**: Instead of using refresh tokens, this approach exchanges the SPA's access token for a federated connection access token
2. **Client-Side Authorization**: Client Login and Step-up authorization is all handled client-side using `@auth0/auth0-spa-js`
3. **Resource Server Client**: Requires a special Resource Server Client configured for federated token exchange
4. **Interrupt Handling**: Federated connection errors are handled in the React client with popup-based re-authorization

### Test your application

1. Start the client & server using Turbo: `npm run dev`
2. Navigate to `http://localhost:5173`
3. Log in with Google and ask your AI agent about your calendar

The application will automatically prompt for additional calendar permissions when needed using Auth0's step-up authorization flow.

That's it! You've successfully integrated federated connections with access tokens into your React SPA + Vercel AI application.

Explore [the example app on GitHub](https://github.com/auth0-lab/auth0-ai-js/tree/main/examples/calling-apis/spa-with-backend-api/react-hono-ai-sdk).
